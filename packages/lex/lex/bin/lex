#!/usr/bin/env -S node --enable-source-maps

/* eslint-env node */
/* eslint-disable @typescript-eslint/no-var-requires */

// This file is referenced by the "bin" field in package.json. Because of that,
// we need this file to exist on disk even before the project is built, so it is
// written in plain JS. This allows package managers to properly link the CLI
// command when the monorepo is being setup (during initial "pnpm install").

const yargs = require('yargs')
const { hideBin } = require('yargs/helpers')
const { LexBuilder } = require('@atproto/lex-builder')
const { LexInstaller } = require('@atproto/lex-installer')

yargs(hideBin(process.argv))
  .strict()
  .command(
    ['build', 'b'],
    'Generate TypeScript lexicon schema files from JSON lexicon definitions',
    (yargs) => {
      return yargs.strict().options({
        lexicons: {
          array: true,
          type: 'string',
          demandOption: true,
          default: './lexicons',
          describe: 'directory containing lexicon JSON files',
        },
        out: {
          type: 'string',
          demandOption: true,
          default: './src/lexicons',
          describe: 'output directory for generated TS files',
        },
        clear: {
          type: 'boolean',
          default: false,
          describe: 'clear output directory before generating files',
        },
        override: {
          type: 'boolean',
          default: false,
          describe: 'override existing files (has no effect with --clear)',
        },
        pretty: {
          type: 'boolean',
          default: true,
          describe: 'run prettier on generated files',
        },
        'ignore-errors': {
          type: 'boolean',
          default: false,
          describe: 'how to handle errors when processing input files',
        },
        'pure-annotations': {
          type: 'boolean',
          default: false,
          describe:
            'adds `/*#__PURE__*/` annotations for tree-shaking tools. Set this to true if you are using generated lexicons in a library.',
        },
        exclude: {
          array: true,
          type: 'string',
          describe:
            'list of strings or regex patterns to exclude lexicon documents by their IDs',
        },
        include: {
          array: true,
          type: 'string',
          describe:
            'list of strings or regex patterns to include lexicon documents by their IDs',
        },
        lib: {
          type: 'string',
          default: '@atproto/lex',
          describe:
            'package name of the library to import the lex schema utility "l" from',
        },
        allowLegacyBlobs: {
          type: 'boolean',
          default: false,
          describe:
            'allow generating schemas that accept legacy blob references',
        },
      })
    },
    async (argv) => {
      await LexBuilder.build(argv)
    },
  )
  .command(
    ['install [nsid..]', 'i [nsid..]'],
    'Fetch and install lexicon documents',
    (yargs) => {
      return yargs.strict().options({
        save: {
          alias: 's',
          type: 'boolean',
          default: false,
          implies: 'nsid',
          describe: 'adds installed lexicon NSIDs to lexicons.json',
        },
        build: {
          type: 'string',
          alias: 'b',
          example: '--build ./src/lexicons',
          describe:
            'output directory to build installed lexicons into (dir content will be overwritten)',
        },
      })
    },
    async (argv) => {
      await LexInstaller.install(argv)

      if (argv.build != null) {
        await LexBuilder.build({
          lexicons: './lexicons',
          out: argv.build || './src/lexicons',
          clear: true,
          pretty: true,
          pureAnnotations: true,
          ignoreErrors: false,
          lib: '@atproto/lex',
        })
      }
    },
  )
  .parseAsync()
