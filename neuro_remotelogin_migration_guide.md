# Neuro RemoteLogin Migration Guide

**Migration from QuickLogin API to RemoteLogin API**

Version: 1.0
Date: January 2, 2026
Status: Planning Phase - **DO NOT IMPLEMENT YET**

---

## Executive Summary

This guide outlines the migration path from the current Neuro **QuickLogin API** implementation to the new **RemoteLogin API** with **Neuro-only authentication**.

**Approach**: Clean-slate deployment - **Password authentication completely removed**. This is a deliberate security decision for a highly secure environment.

**User Impact**:
- New users: Must have Neuro account with verified Legal ID
- Existing users: Will be unable to login if they only have password-based accounts
- **This is an accepted risk** - security over convenience

**Estimated Effort**: 2-3 weeks (including testing)
**Complexity**: Medium (simplified by removing dual-auth logic)
**Breaking Changes**: Yes (removes all password authentication)
**Risk Level**: HIGH - User lockout is intentional tradeoff for maximum security

---

## Table of Contents

1. [API Comparison](#1-api-comparison)
2. [Pre-Migration Checklist](#2-pre-migration-checklist)
3. [Architecture Changes](#3-architecture-changes)
4. [Database Schema Changes](#4-database-schema-changes)
5. [Code Changes by Component](#5-code-changes-by-component)
6. [Testing Strategy](#6-testing-strategy)
7. [Deployment Strategy](#7-deployment-strategy)
8. [Rollback Plan](#8-rollback-plan)
9. [Post-Migration Validation](#9-post-migration-validation)
10. [Open Questions & Decisions Needed](#10-open-questions--decisions-needed)
11. [Risk Assessment](#11-risk-assessment)

---

## 1. API Comparison

### 1.1 QuickLogin (Current Implementation)

**Flow**: User-initiated → PDS responds
```
User scans QR → Neuro calls PDS → PDS receives identity data
```

**Endpoint**: `POST /QuickLogin`

**Request**:
```json
{
  "callbackUrl": "https://pds.example.com/neuro/callback",
  "sessionId": "session-123"
}
```

**Response**:
```json
{
  "serviceId": "service-abc"
}
```

**Callback Payload** (from Neuro to PDS):
```json
{
  "sessionId": "session-123",
  "jid": "user@lab.tagroot.io",
  "userName": "username",
  "email": "user@example.com",
  "legalId": "GUID@legal.lab.tagroot.io"
}
```

**Key Characteristics**:
- ✅ User initiates by scanning QR
- ✅ Public API (no authentication required)
- ✅ Returns raw identity data
- ✅ Discover user identity after scan
- ❌ QR code required for UX

---

### 1.2 RemoteLogin (Target Implementation)

**Flow**: Service-initiated → User approves
```
PDS requests authentication → User approves in app → Neuron calls PDS
```

**Endpoint**: `POST /RemoteLogin`

**Request**:
```json
{
  "AddressType": "LegalId",
  "Address": "GUID@legal.lab.tagroot.io",
  "ResponseMethod": "Callback",
  "CallbackURL": "https://pds.example.com/neuro/callback",
  "Seconds": 300,
  "Purpose": "Sign up for @alice.bsky.social"
}
```

**Response**:
```json
{
  "PetitionId": "petition-xyz"
}
```

**Callback Payload** (from Neuron to PDS):
```json
{
  "PetitionId": "petition-xyz",
  "Rejected": false,
  "Token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**JWT Token Claims**:
```json
{
  "jti": "unique-token-id",
  "iss": "lab.tagroot.io",
  "client_id": "GUID@legal.lab.tagroot.io",
  "sub": "GUID@legal.lab.tagroot.io",
  "aud": "pds.example.com",
  "iat": 1735689600,
  "exp": 1735689900
}
```

**Key Characteristics**:
- ✅ Service initiates authentication
- ✅ Push notifications (QR optional)
- ✅ Returns JWT token (signed)
- ✅ Transparent purpose shown to user
- ⚠️ Requires knowing Legal ID/JID upfront
- ⚠️ Requires PDS authentication credentials
- ⚠️ Requires privilege grants from Neuron admin

---

### 1.3 Major Differences Summary

| Feature | QuickLogin | RemoteLogin |
|---------|-----------|-------------|
| **Initiation** | User-initiated (QR scan) | Service-initiated (PDS request) |
| **Endpoint** | `/QuickLogin` | `/RemoteLogin` |
| **Authentication** | Public API | Requires PDS credentials + privileges |
| **User Identifier** | Discovered after scan | Must be known before request |
| **Response Format** | Raw identity object | JWT token |
| **User Experience** | QR code required | Push notification (QR optional) |
| **Purpose Message** | Not shown to user | Shown to user before approval |
| **Security** | Identity data in callback | Signed JWT token in callback |
| **Session ID** | Generated by PDS | PetitionId generated by Neuron |

---

## 2. Pre-Migration Checklist

### 2.1 Neuron Administrator Tasks

Before implementing RemoteLogin, coordinate with Neuron administrator:

- [ ] **Obtain PDS Credentials**
  - WWW-Authenticate credentials (username/password)
  - OR Bearer token
  - OR mTLS certificate
  - Document which method is used

- [ ] **Request Privilege Grants**
  ```
  Required privileges:
  - RemoteLogin.Method.Callback
  - RemoteLogin.Type.LegalId
  - RemoteLogin.Type.JID (optional, if supporting JID login)
  - RemoteLogin.Domain.io.tagroot.lab (adjust for your domain)
  ```

- [ ] **Test Credentials**
  - Verify PDS can authenticate to Neuron API
  - Test privilege verification
  - Document any IP restrictions or rate limits

### 2.2 Product/UX Decisions

- [ ] **Legal ID Collection Strategy**
  - How will users provide their Legal ID during signup?
    - Option A: Manual entry (text input)
    - Option B: QR code scan to extract Legal ID
    - Option C: Email-based lookup (if Neuron supports)
    - Option D: Hybrid approach

- [ ] **Existing User Migration** ⚠️ **CRITICAL DECISION**
  - **Problem**: Removing password auth locks out existing password-based users
  - **Options**:
    - A. Force all users to create Neuro accounts and link Legal IDs
    - B. Maintain password auth indefinitely for existing users (dual auth)
    - C. Give users migr ⚠️ **NEURO-ONLY APPROACH**
  ```
  Current QuickLogin Flow:
  1. Enter handle + email + password
  2. Account created (with optional Neuro linking)

  NEW: Neuro-Only RemoteLogin Flow:
  1. User must have Neuro account with verified Legal ID (PREREQUISITE)
  2. Enter handle + email + Legal ID (in place of password field)
  3. Submit → "Check your Neuro app"
  4. User approves petition in app (push notification)
  5. Account created (passwordless)
  ```
  **Decision**: Neuro-only (password auth removed for new users)

  **Implications**:
  - All new users MUST have Neuro account before signup
  - Higher barrier to entry (identity verification required)
  - No quick "email + password" signup
  - Marketing/onboarding must explain Neuro requirement
  2. Submit → "Check your Neuro app"
  3. User approves in app (push notification)
  4. Account created
  ```
  Decision: Keep both flows or remove QuickLogin?

- [ ] **Error Handling UX**
  - User rejects petition → Show what?
  - Petition expires (5 min) → Retry flow?
  - Legal ID not found → Guidance message?

### 2.3 Technical Decisions

- [ ] **Storage Backend**
  - Current: Database (`neuro_pending_session` table)
  - Decision: Keep database or switch to Redis for petition tracking?
  - Recommendation: Database (simpler, already implemented)

- [ ] **JWT Verification**
  - Decision: Verify JWT signature?
  - If yes: Obtain Neuron's public keys (JWKS endpoint)
  - If no: Document security implications
  - Recommendation: Verify if JWKS available, else trust network security

- [ ] **Identifier Strategy**
  - Current database: `neuroJid` (JID)
  - New API: `LegalId` (recommended)
  - Decision: Add `legalId` column (keep JID for reference)
  - Migration: New users only have Legal ID, no JID needed

---

## 3. Architecture Changes

### 3.1 Current Architecture (QuickLogin)

```
┌──────────────────────────────────────────────────────┐
│                    PDS Server                         │
│                                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │         NeuroAuthManager                     │    │
│  │                                              │    │
│  │  initiateSession()                           │    │
│  │    └─> POST /QuickLogin                      │    │
│  │    └─> Store session in memory/DB            │    │
│  │    └─> Return QR code URL                    │    │
│  │                                              │    │
│  │  handleCallback(identity)                    │    │
│  │    └─> Receive raw identity data             │    │
│  │    └─> Emit to waiting promise               │    │
│  │    └─> No JWT parsing                        │    │
│  │                                              │    │
│  │  waitForIdentity(sessionId)                  │    │
│  │    └─> Promise-based waiting                 │    │
│  └─────────────────────────────────────────────┘    │
│                                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │     POST /neuro/callback                     │    │
│  │       └─> Extract identity from body         │    │
│  │       └─> Call handleCallback()              │    │
│  └─────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

### 3.2 Target Architecture (RemoteLogin)

```
┌──────────────────────────────────────────────────────┐
│                    PDS Server                         │
│                                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │    NeuroRemoteLoginManager (NEW)             │    │
│  │                                              │    │
│  │  initiatePetition(legalId, purpose)          │    │
│  │    └─> Authenticate with Neuron              │    │
│  │    └─> POST /RemoteLogin                     │    │
│  │    └─> Store petition in DB/Redis            │    │
│  │    └─> Return petition ID                    │    │
│  │                                              │    │
│  │  handleCallback(petition)                    │    │
│  │    └─> Extract JWT token                     │    │
│  │    └─> Verify JWT signature (optional)       │    │
│  │    └─> Parse JWT claims                      │    │
│  │    └─> Extract Legal ID from 'sub'           │    │
│  │    └─> Emit to waiting promise               │    │
│  │                                              │    │
│  │  waitForApproval(petitionId)                 │    │
│  │    └─> Promise-based waiting                 │    │
│  │    └─> Timeout after 5 minutes               │    │
│  └─────────────────────────────────────────────┘    │
│                                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │  POST /neuro/remotelogin/callback (NEW)      │    │
│  │    └─> Extract PetitionId, Token             │    │
│  │    └─> Handle Rejected = true                │    │
│  │    └─> Call handleCallback()                 │    │
│  └─────────────────────────────────────────────┘    │
│                                                       │
│  ┌─────────────────────────────────────────────┐    │
│  │         NeuronAuthClient (NEW)               │    │
│  │    └─> Manages credentials                   │    │
│  │    └─> Adds Authorization header             │    │
│  │    └─> Handles credential refresh            │    │
│  └─────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

### 3.3 Key Architectural Differences

1. **Authentication Layer** (NEW)
   - Current: No authentication needed
   - Target: Inject `Authorization` header on every request
   - Implementation: `NeuronAuthClient` class

2. **Token Parsing** (NEW)
   - Current: Raw identity object
   - Target: JWT parsing with `jose` library
   - Implementation: JWT verification method

3. **Legal ID Management** (NEW)
   - Current: Discover JID after scan
   - Target: Must know Legal ID before petition
   - Implementation: UI changes + database lookups

4. **Petition Tracking** (CHANGED)
   - Current: Session-based (sessionId)
   - Target: Petition-based (PetitionId)
   - Implementation: Different correlation mechanism

5. **Rejection Handling** (NEW)
   - Current: No rejection mechanism
   - Target: Handle `Rejected: true` callbacks
   - Implementation: Error state management

---

## 4. Database Schema Changes

### 4.1 Current Schema

```typescript
// Table: neuro_identity_link
interface NeuroIdentityLink {
  neuroJid: string          // Primary key: JID
  did: string               // PDS account DID
  email: string | null
  userName: string | null
  linkedAt: string          // ISO timestamp
  lastLoginAt: string | null
}

// Table: neuro_pending_session
interface NeuroPendingSession {
  sessionId: string         // Primary key
  serviceId: string         // QuickLogin service ID
  requestUri: string | null
  deviceId: string | null
  createdAt: string
  expiresAt: string
  completedAt: string | null
  neuroJid: string | null
}
```

### 4.2 Required Schema Changes

#### Option A: Minimal Changes (Recommended for initial migration)

```typescript
// Table: neuro_identity_link (MODIFIED)
interface NeuroIdentityLink {
  neuroJid: string          // Primary key: Keep for backward compat
  legalId: string | null    // NEW: Add Legal ID column
  did: string
  email: string | null
  userName: string | null
  linkedAt: string
  lastLoginAt: string | null
}

// Table: neuro_pending_petition (RENAMED from neuro_pending_session)
interface NeuroPendingPetition {
  petitionId: string        // Primary key (CHANGED from sessionId)
  legalId: string          // CHANGED: Legal ID instead of JID
  purpose: string          // NEW: Purpose message
  requestUri: string | null
  deviceId: string | null
  createdAt: string
  expiresAt: string
  completedAt: string | null
  approved: boolean | null  // NEW: Track approval status
  jwtToken: string | null   // NEW: Store JWT (optional)
}
```

**Migration SQL**:
```sql
-- Add legalId column to neuro_identity_link
ALTER TABLE neuro_identity_link
ADD COLUMN legalId VARCHAR;

-- Create index on legalId for fast lookups
CREATE INDEX neuro_identity_link_legal_id_idx
ON neuro_identity_link(legalId);

-- Rename table (or create new one for dual support)
ALTER TABLE neuro_pending_session
RENAME TO neuro_pending_petition;

-- Add new columns
ALTER TABLE neuro_pending_petition
ADD COLUMN purpose VARCHAR;

ALTER TABLE neuro_pending_petition
ADD COLUMN approved BOOLEAN;

ALTER TABLE neuro_pending_petition
ADD COLUMN jwtToken TEXT;

-- Rename sessionId to petitionId (database-specific syntax)
-- PostgreSQL example:
ALTER TABLE neuro_pending_petition
RENAME COLUMN sessionId TO petitionId;

ALTER TABLE neuro_pending_petition
RENAME COLUMN serviceId TO legalId;

ALTER TABLE neuro_pending_petition
RENAME COLUMN neuroJid TO responseData; -- Or drop if not needed
```

#### Option B: Clean Slate (Recommended for long-term)

Create entirely new tables with clean schema:

```sql
-- Create new table for RemoteLogin identity links
CREATE TABLE neuro_remote_identity (
  legalId VARCHAR PRIMARY KEY,
  jid VARCHAR,                    -- Optional: Keep JID if available
  did VARCHAR NOT NULL,
  email VARCHAR,
  userName VARCHAR,
  linkedAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  lastLoginAt TIMESTAMP,

  INDEX idx_did (did),
  INDEX idx_jid (jid)
);

-- Create new table for RemoteLogin petitions
CREATE TABLE neuro_remote_petition (
  petitionId VARCHAR PRIMARY KEY,
  legalId VARCHAR NOT NULL,
  purpose VARCHAR NOT NULL,
  callbackUrl VARCHAR NOT NULL,
  deviceId VARCHAR,
  createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  expiresAt TIMESTAMP NOT NULL,
  completedAt TIMESTAMP,
  approved BOOLEAN,
  jwtToken TEXT,

  INDEX idx_expires (expiresAt),
  INDEX idx_legal_id (legalId)
);
```

**Data Migration**:
```sql
-- Migrate existing QuickLogin identities to RemoteLogin
-- NOTE: Legal IDs must be obtained separately (e.g., via Neuron API query)
INSERT INTO neuro_remote_identity (legalId, jid, did, email, userName, linkedAt, lastLoginAt)
SELECT
  NULL as legalId,  -- TODO: Populate via Neuron API or user re-link
  neuroJid as jid,
  did,
  email,
  userName,
  linkedAt,
  lastLoginAt
FROM neuro_identity_link;
```

### 4.3 Migration Considerations

**Decision Point**: Choose migration strategy
- **Option A**: Faster, backward compatible, messier schema
- **Option B**: Cleaner, requires data migration, supports dual APIs

**Recommendation**: Start with **Option A** for rapid prototyping, migrate to **Option B** for production.

---

## 5. Code Changes by Component

### 5.1 Configuration Changes

**File**: `packages/pds/src/config/env.ts`

**Current**:
```typescript
neuro: envBool('PDS_NEURO_ENABLED')
  ? ({
      enabled: true,
      domain: envStr('PDS_NEURO_DOMAIN') || 'mateo.lab.tagroot.io',
      storageBackend:
        (envStr('PDS_NEURO_STORAGE_BACKEND') as 'database' | 'redis') || 'database',
    } as const)
  : ({ enabled: false } as const)
```

**Target**:
```typescript
neuro: envBool('PDS_NEURO_ENABLED')
  ? ({
      enabled: true,
      domain: envStr('PDS_NEURO_DOMAIN') || 'mateo.lab.tagroot.io',
      storageBackend:
        (envStr('PDS_NEURO_STORAGE_BACKEND') as 'database' | 'redis') || 'database',

      // NEW: RemoteLogin-specific config
      apiType: envStr('PDS_NEURO_API_TYPE') || 'remotelogin', // 'quicklogin' | 'remotelogin' | 'both'

      // NEW: Authentication credentials
      authMethod: envStr('PDS_NEURO_AUTH_METHOD') || 'bearer', // 'bearer' | 'basic' | 'mtls'
      bearerToken: envStr('PDS_NEURO_BEARER_TOKEN'),
      basicUsername: envStr('PDS_NEURO_BASIC_USERNAME'),
      basicPassword: envStr('PDS_NEURO_BASIC_PASSWORD'),
      mtlsCertPath: envStr('PDS_NEURO_MTLS_CERT'),
      mtlsKeyPath: envStr('PDS_NEURO_MTLS_KEY'),

      // NEW: JWT verification
      verifyJwtSignature: envBool('PDS_NEURO_VERIFY_JWT') ?? true,
      jwksUrl: envStr('PDS_NEURO_JWKS_URL'), // Optional: For JWT verification

      // NEW: Default petition settings
      defaultPetitionSeconds: parseInt(envStr('PDS_NEURO_PETITION_TIMEOUT') || '300'),

    } as const)
  : ({ enabled: false } as const)
```

**New Environment Variables**:
```bash
# .env additions
PDS_NEURO_API_TYPE="remotelogin"
PDS_NEURO_AUTH_METHOD="bearer"
PDS_NEURO_BEARER_TOKEN="your-token-here"
PDS_NEURO_VERIFY_JWT="true"
PDS_NEURO_PETITION_TIMEOUT="300"
```

---

### 5.2 New Component: NeuronAuthClient

**File**: `packages/pds/src/account-manager/helpers/neuron-auth-client.ts` (NEW)

**Purpose**: Manage authentication with Neuron API

**Implementation**:
```typescript
/**
 * Handles authentication for RemoteLogin API requests
 */
export class NeuronAuthClient {
  constructor(private config: NeuroConfig) {}

  /**
   * Get Authorization header value
   */
  getAuthHeader(): string {
    switch (this.config.authMethod) {
      case 'bearer':
        if (!this.config.bearerToken) {
          throw new Error('Bearer token not configured')
        }
        return `Bearer ${this.config.bearerToken}`

      case 'basic':
        if (!this.config.basicUsername || !this.config.basicPassword) {
          throw new Error('Basic auth credentials not configured')
        }
        const credentials = Buffer.from(
          `${this.config.basicUsername}:${this.config.basicPassword}`
        ).toString('base64')
        return `Basic ${credentials}`

      case 'mtls':
        // mTLS handled at TLS layer, no header needed
        return ''

      default:
        throw new Error(`Unknown auth method: ${this.config.authMethod}`)
    }
  }

  /**
   * Get fetch options with authentication
   */
  getAuthenticatedFetchOptions(
    method: string,
    body?: object
  ): RequestInit {
    const options: RequestInit = {
      method,
      headers: {
        'Content-Type': 'application/json',
      },
    }

    // Add auth header if needed
    const authHeader = this.getAuthHeader()
    if (authHeader) {
      options.headers['Authorization'] = authHeader
    }

    // Add mTLS certificates if configured
    if (this.config.authMethod === 'mtls') {
      if (!this.config.mtlsCertPath || !this.config.mtlsKeyPath) {
        throw new Error('mTLS certificate paths not configured')
      }

      // Node.js fetch doesn't support cert/key directly
      // Need to use https.Agent with cert/key
      // TODO: Implement mTLS agent
    }

    // Add body
    if (body) {
      options.body = JSON.stringify(body)
    }

    return options
  }
}
```

---

### 5.3 Modified Component: NeuroAuthManager → NeuroRemoteLoginManager

**File**: `packages/pds/src/account-manager/helpers/neuro-remotelogin-manager.ts` (RENAMED)

**Changes**:

#### A. Constructor Changes

**Current**:
```typescript
constructor(
  private readonly config: NeuroConfig,
  storageBackend?: AccountDb | Redis,
  logger?: Logger,
)
```

**Target**:
```typescript
constructor(
  private readonly config: NeuroConfig,
  private readonly authClient: NeuronAuthClient, // NEW
  storageBackend?: AccountDb | Redis,
  logger?: Logger,
)
```

#### B. Method: `initiateSession()` → `initiatePetition()`

**Current Method**:
```typescript
async initiateSession(
  requestUri?: string,
  deviceId?: string,
): Promise<{
  sessionId: string
  serviceId: string
  qrCodeUrl: string
  verificationCode: string
}>
```

**Target Method**:
```typescript
async initiatePetition(
  legalId: string,           // NEW: Required parameter
  purpose: string,           // NEW: User-facing message
  requestUri?: string,
  deviceId?: string,
): Promise<{
  petitionId: string         // CHANGED from sessionId
  qrCodeUrl?: string         // CHANGED: Optional
}>
```

**Implementation Changes**:

**Current**:
```typescript
async initiateSession(...) {
  const sessionId = randomBytes(16).toString('hex')
  const callbackUrl = `${this.config.callbackBaseUrl}/neuro/callback`

  const fetchResponse = await fetch(
    `${protocol}://${this.config.domain}/QuickLogin`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ callbackUrl, sessionId }),
    },
  )

  const response = await fetchResponse.json()
  const { serviceId } = response

  // Generate QR code URL
  const qrCodeUrl = `https://${this.config.domain}/QuickLogin/${serviceId}.png`

  return { sessionId, serviceId, qrCodeUrl, verificationCode }
}
```

**Target**:
```typescript
async initiatePetition(legalId: string, purpose: string, ...) {
  const callbackUrl = `${this.config.callbackBaseUrl}/neuro/remotelogin/callback`

  // Use authenticated client
  const fetchOptions = this.authClient.getAuthenticatedFetchOptions('POST', {
    AddressType: 'LegalId',
    Address: legalId,
    ResponseMethod: 'Callback',
    CallbackURL: callbackUrl,
    Seconds: this.config.defaultPetitionSeconds || 300,
    Purpose: purpose,
  })

  const protocol = this.config.domain.startsWith('localhost') ? 'http' : 'https'
  const fetchResponse = await fetch(
    `${protocol}://${this.config.domain}/RemoteLogin`,
    fetchOptions,
  )

  if (!fetchResponse.ok) {
    const error = await fetchResponse.text()
    throw new Error(`RemoteLogin API error: ${error}`)
  }

  const response = await fetchResponse.json()
  const { PetitionId } = response

  // Store petition
  await this.storePetition(PetitionId, legalId, purpose, requestUri, deviceId)

  // QR code is OPTIONAL with RemoteLogin (push notification is primary)
  // Generate QR only if specifically needed for UX
  const qrCodeUrl = undefined // Or: Generate QR with PetitionId

  return { petitionId: PetitionId, qrCodeUrl }
}
```

#### C. Method: `handleCallback()` - JWT Parsing

**Current**:
```typescript
handleCallback(identity: NeuroIdentity): void {
  const session = this.sessions.get(identity.sessionId)
  // ... store raw identity
  session.identity = identity
  session.emitter.emit('identity', identity)
}
```

**Target**:
```typescript
handleCallback(payload: {
  PetitionId: string
  Rejected: boolean
  Token: string
}): void {
  const petition = this.petitions.get(payload.PetitionId)

  if (!petition) {
    throw new Error(`Petition not found: ${payload.PetitionId}`)
  }

  // Handle rejection
  if (payload.Rejected) {
    petition.approved = false
    petition.emitter.emit('rejected', new Error('User rejected authentication'))
    return
  }

  // Parse JWT token
  const claims = this.parseJwtToken(payload.Token)

  // Extract Legal ID from token
  const legalId = claims.sub // or claims.client_id

  // Store approval
  petition.approved = true
  petition.legalId = legalId
  petition.jwtToken = payload.Token
  petition.completedAt = Date.now()

  // Emit approval event with claims
  petition.emitter.emit('approved', { legalId, claims, token: payload.Token })
}

/**
 * Parse and optionally verify JWT token
 */
private parseJwtToken(token: string): JWTClaims {
  if (this.config.verifyJwtSignature) {
    // TODO: Implement JWT signature verification
    // Requires JWKS endpoint or public key from Neuron
    // Use jose library: await jwtVerify(token, publicKey)
    throw new Error('JWT verification not yet implemented')
  }

  // Parse without verification (decode only)
  const parts = token.split('.')
  if (parts.length !== 3) {
    throw new Error('Invalid JWT format')
  }

  const payload = Buffer.from(parts[1], 'base64url').toString('utf-8')
  const claims = JSON.parse(payload)

  // Validate required claims
  if (!claims.sub || !claims.iss || !claims.exp) {
    throw new Error('JWT missing required claims')
  }

  // Check expiration
  const now = Math.floor(Date.now() / 1000)
  if (claims.exp < now) {
    throw new Error('JWT token expired')
  }

  return claims
}
```

#### D. Method: `waitForIdentity()` → `waitForApproval()`

**Current**:
```typescript
async waitForIdentity(sessionId: string): Promise<NeuroIdentity>
```

**Target**:
```typescript
async waitForApproval(petitionId: string): Promise<{
  legalId: string
  claims: JWTClaims
  token: string
}>
```

#### E. Method: `linkIdentity()` - Add Legal ID Support

**Current**:
```typescript
async linkIdentity(
  jid: string,
  did: string,
  email?: string,
  userName?: string,
): Promise<void> {
  await this.db.db
    .insertInto('neuro_identity_link')
    .values({
      neuroJid: jid,
      did,
      email: email || null,
      userName: userName || null,
      linkedAt: new Date().toISOString(),
      lastLoginAt: null,
    })
    .execute()
}
```

**Target**:
```typescript
async linkIdentity(
  legalId: string,        // NEW: Primary identifier
  did: string,
  jid?: string,           // CHANGED: Optional
  email?: string,
  userName?: string,
): Promise<void> {
  await this.db.db
    .insertInto('neuro_identity_link')
    .values({
      legalId,              // NEW
      neuroJid: jid || null, // Backward compat
      did,
      email: email || null,
      userName: userName || null,
      linkedAt: new Date().toISOString(),
      lastLoginAt: null,
    })
    .execute()
}
```

#### F. Method: `findAccountByNeuroJid()` → `findAccountByLegalId()`

**Current**:
```typescript
async findAccountByNeuroJid(jid: string): Promise<{ did: string } | null>
```

**Target**:
```typescript
async findAccountByLegalId(legalId: string): Promise<{ did: string } | null> {
  const result = await this.db.db
    .selectFrom('neuro_identity_link')
    .select('did')
    .where('legalId', '=', legalId)
    .executeTakeFirst()

  return result || null
}

// Keep for backward compatibility during transition
async findAccountByNeuroJid(jid: string): Promise<{ did: string } | null> {
  const result = await this.db.db
    .selectFrom('neuro_identity_link')
    .select('did')
    .where('neuroJid', '=', jid)
    .executeTakeFirst()

  return result || null
}
```

---

### 5.4 Route Handler Changes

**File**: `packages/pds/src/basic-routes.ts`

**Current**:
```typescript
router.post('/neuro/callback', async function (req, res) {
  const { sessionId, jid, userName, email, eMail, ...otherFields } = req.body

  // Validate required fields
  if (!sessionId || !jid) {
    return res.status(400).json({ error: 'Missing required fields' })
  }

  ctx.neuroAuthManager.handleCallback({
    sessionId,
    jid,
    userName,
    email,
    eMail,
    ...otherFields,
  })

  res.json({ success: true })
})
```

**Target** (add new route):
```typescript
// NEW: RemoteLogin callback handler
router.post('/neuro/remotelogin/callback', async function (req, res) {
  const { PetitionId, Rejected, Token } = req.body

  // Validate required fields
  if (!PetitionId || typeof Rejected !== 'boolean') {
    req.log.warn({ body: req.body }, 'RemoteLogin callback missing fields')
    return res.status(400).json({
      error: 'Missing required fields',
      code: 'NEURO_CALLBACK_MISSING_FIELDS',
      details: 'PetitionId and Rejected are required',
    })
  }

  // Token required if not rejected
  if (!Rejected && !Token) {
    return res.status(400).json({
      error: 'Token required when not rejected',
      code: 'NEURO_CALLBACK_MISSING_TOKEN',
    })
  }

  try {
    if (!ctx.neuroRemoteLoginManager) {
      return res.status(503).json({
        success: false,
        code: 'NEURO_NOT_CONFIGURED',
        message: 'Neuro RemoteLogin not configured',
      })
    }

    ctx.neuroRemoteLoginManager.handleCallback({
      PetitionId,
      Rejected,
      Token,
    })

    req.log.info(
      {
        petitionId: PetitionId.substring(0, 8) + '...',
        rejected: Rejected,
      },
      'RemoteLogin callback processed',
    )

    res.json({ success: true })
  } catch (error) {
    req.log.error({ error, body: req.body }, 'RemoteLogin callback error')
    res.status(500).json({
      success: false,
      error: error.message,
    })
  }
})

// OPTIONAL: Keep QuickLogin callback for backward compatibility
router.post('/neuro/callback', async function (req, res) {
  // ... existing QuickLogin handler
})
```

---

### 5.5 OAuth Store Changes

**File**: `packages/pds/src/account-manager/oauth-store.ts`

**Method**: `createAccount()`

**Current**:
```typescript
async createAccount({ locale, inviteCode, handle, email, password, emailOtp }) {
  // Check if this is a Neuro signup (no password + verification code)
  if (!password && emailOtp && this.neuroAuthManager) {
    const sessionId = this.neuroAuthManager.getSessionByCode(emailOtp)

    if (!sessionId) {
      throw new InvalidRequestError('Invalid or expired verification code')
    }

    const identity = this.neuroAuthManager.getSessionIdentity(sessionId)

    return this.createAccountWithNeuro({
      handle,
      email,
      inviteCode,
      locale,
      identity,
    })
  }

  // ... standard password-based signup
}
```

**Target**:
```typescript
async createAccount({ locale, inviteCode, handle, email, password, emailOtp, legalId }) {
  // Check if this is a Neuro signup
  if (legalId && this.neuroRemoteLoginManager) {
    // NEW: Legal ID provided - use RemoteLogin

    // Initiate petition
    const purpose = `Sign up for @${handle}`
    const { petitionId } = await this.neuroRemoteLoginManager.initiatePetition(
      legalId,
      purpose,
      undefined, // requestUri
      undefined, // deviceId
    )

    // Wait for user approval (with timeout)
    const approval = await this.neuroRemoteLoginManager.waitForApproval(petitionId)

    return this.createAccountWithNeuro({
      handle,
      email,
      inviteCode,
      locale,
      legalId: approval.legalId,
      jwtClaims: approval.claims,
    })
  }

  // BACKWARD COMPAT: QuickLogin with verification code
  if (!password && emailOtp && this.neuroAuthManager) {
    // ... existing QuickLogin logic
  }

  // ... standard password-based signup
}

private async createAccountWithNeuro(data: {
  handle: string
  email: string
  inviteCode?: string
  locale?: string
  legalId: string        // CHANGED: Required
  jwtClaims?: JWTClaims  // NEW: Optional JWT claims
}) {
  // Verify handle availability
  await this.verifyHandleAvailability(data.handle)

  // Create account (same as before)
  const signingKey = await Secp256k1Keypair.create({ exportable: true })
  // ... create DID, repo, etc.

  // Link Neuro identity with Legal ID
  await this.neuroRemoteLoginManager.linkIdentity(
    data.legalId,
    did,
    undefined, // jid (not available from RemoteLogin)
    data.email,
    data.handle,
  )

  return account
}
```

---

### 5.6 UI/Frontend Changes

**Location**: OAuth provider UI (if applicable)

**Changes Required**:

1. **Signup Form** - Add Legal ID input
   ```tsx
   // packages/oauth/oauth-provider-ui/src/views/authorize/sign-up/sign-up-account-form.tsx

   // Add new input field
   const [legalId, setLegalId] = useState('')

   <input
     type="text"
     placeholder="Legal ID (e.g., GUID@legal.lab.tagroot.io)"
     value={legalId}
     onChange={(e) => setLegalId(e.target.value)}
     pattern="[^@]+@legal\.[a-z0-9.-]+"
     required={neuroEnabled}
   />
   ```

2. **Waiting State** - Update messaging
   ```tsx
   // After submitting signup with Legal ID
   <div>
     <h3>Check your Neuro app</h3>
     <p>We've sent an authentication request to your Neuro app.</p>
     <p>Please approve the request to complete signup.</p>

     {/* Optional QR code for convenience */}
     {qrCodeUrl && (
       <img src={qrCodeUrl} alt="Scan with Neuro app" />
     )}

     <button onClick={cancelPetition}>Cancel</button>
   </div>
   ```

3. **Error Handling** - Handle rejection
   ```tsx
   // If user rejects petition
   <div className="error">
     <p>Authentication was denied.</p>
     <p>Please try again or contact support.</p>
     <button onClick={retrySignup}>Try Again</button>
   </div>
   ```

---

## 6. Testing Strategy

### 6.1 Unit Tests

**File**: `packages/pds/tests/neuro-remotelogin.test.ts` (NEW)

**Test Cases**:

```typescript
describe('Neuro RemoteLogin Integration', () => {
  describe('NeuronAuthClient', () => {
    it('should generate Bearer token auth header')
    it('should generate Basic auth header')
    it('should handle mTLS configuration')
    it('should throw error when credentials missing')
  })

  describe('NeuroRemoteLoginManager', () => {
    it('should initiate petition with Legal ID')
    it('should include Purpose in petition request')
    it('should handle petition response')
    it('should parse JWT token from callback')
    it('should verify JWT signature when configured')
    it('should handle expired JWT tokens')
    it('should handle rejected petitions')
    it('should timeout after configured duration')
    it('should link identity with Legal ID')
    it('should find account by Legal ID')
  })

  describe('RemoteLogin Callback Endpoint', () => {
    it('should accept valid RemoteLogin callback')
    it('should reject callback with missing PetitionId')
    it('should reject callback with missing Token (when not rejected)')
    it('should handle rejection callbacks')
  })

  describe('OAuth Store Integration', () => {
    it('should create account with Legal ID')
    it('should wait for petition approval during signup')
    it('should handle timeout during signup')
    it('should handle rejection during signup')
  })
})
```

### 6.2 Integration Tests

**Test with Mock Server**:

1. Update `mock-neuro-server/server.js` to support both APIs
2. Run tests against both QuickLogin and RemoteLogin endpoints
3. Verify dual-API support during transition

**Test Scenarios**:
- [ ] Signup with Legal ID → Approve → Account created
- [ ] Signup with Legal ID → Reject → Error shown
- [ ] Signup with Legal ID → Timeout → Error shown
- [ ] Login with Legal ID → Approve → Session created
- [ ] Login with Legal ID → Reject → Error shown
- [ ] JWT token verification (if enabled)
- [ ] Invalid JWT token → Error
- [ ] Expired JWT token → Error

### 6.3 Manual Testing

**Checklist**:
- [ ] Test with real Neuron instance (staging environment)
- [ ] Verify push notifications work
- [ ] Test QR code flow (if implemented)
- [ ] Test petition expiration handling
- [ ] Test concurrent petitions for same user
- [ ] Test rejection flow end-to-end
- [ ] Verify Legal ID collection UX
- [ ] Load testing with multiple simultaneous petitions

---

## 7. Deployment Strategy

### 7.1 Phased Rollout

**Phase 1: Preparation (Week 1)**
- [ ] Obtain Neuron credentials
- [ ] Test credentials in staging
- [ ] Deploy database migrations to staging
- [ ] Deploy code changes to staging
- [ ] Run integration tests against staging
- [ ] User acceptance testing
- [ ] Performance testing

**Phase 2: Production Deployment (Week 2)**
- [ ] Deploy database migrations to production
- [ ] Deploy Neuro-only authentication code
- [ ] Remove password authentication endpoints
- [ ] Monitor signup completion rate closely
- [ ] Track Neuro API error rates
- [ ] 24/7 on-call for first 48 hours

**Phase 3: Optimization (Week 3+)**
- [ ] Gather user feedback on Neuro onboarding
- [ ] Optimize Legal ID input UX based on errors
- [ ] Tune petition timeout values
- [ ] Update documentation based on support tickets
- [ ] Monitor conversion funnel metrics

### 7.2 Feature Flags

**Recommended Flags**:
```typescript
interface FeatureFlags {
  neuro_remotelogin_enabled: boolean       // Enable RemoteLogin API
  neuro_jwt_verification_enabled: boolean  // Enable JWT signature verification
  neuro_petition_timeout_seconds: number   // Petition timeout (default: 300)
}
```

**Gradual Rollout**:
```typescript
// Initial deployment - monitor closely
neuro_remotelogin_enabled: true
neuro_jwt_verification_enabled: false  // Enable after testing
neuro_petition_timeout_seconds: 300

// After validation - enable JWT verification
neuro_remotelogin_enabled: true
neuro_jwt_verification_enabled: true
neuro_petition_timeout_seconds: 300
```

---

## 8. Rollback Plan

### 8.1 Rollback Triggers

Rollback if:
- [ ] Neuro API returns >5% error rate for >1 hour
- [ ] New user signup completion drops >30%
- [ ] Neuron authentication fails consistently (>10% failure rate)
- [ ] JWT token verification causes >10% signup failures
- [ ] Neuro downtime lasts >6 hours
- [ ] Critical security vulnerability discovered in Neuro integration

### 8.2 Rollback Steps

**Emergency Rollback** (if Neuro completely unavailable):

⚠️ **IMPORTANT**: Clean-slate Neuro-only has NO fallback authentication. If Neuro is down, ALL authentication stops.

**Mitigation Options**:
1. **Wait for Neuron**: If downtime expected to be <6 hours
   - Display status page to users
   - Communicate via email/Twitter
   - Monitor Neuron status page

2. **Emergency Password Re-enable** (requires pre-planning):
   - Deploy emergency feature flag: `emergency_password_auth_enabled: true`
   - Temporarily allow password signup/login
   - Migrate users back to password (temporary)
   - **Risk**: Defeats security goals of Neuro-only approach

3. **Partial Rollback**:
   - Keep Neuro for users who successfully signed up
   - Enable password auth for NEW signups only (temporary)
   - Plan migration back to Neuro once stable

**Standard Rollback** (code issues):
1. Revert code deployment
2. Roll back database migrations (if safe)
3. Re-enable QuickLogin API endpoints (if still exists)
4. Communicate status to users
5. Post-mortem and fix

### 8.3 Rollback Testing

**Pre-Deployment Validation**:
- [ ] Test feature flag toggle in staging
- [ ] Test code rollback procedure in staging
- [ ] Verify QuickLogin still works
- [ ] Verify existing accounts not affected

---

## 9. Post-Migration Validation

### 9.1 Success Metrics

**Week 1**:
- [ ] RemoteLogin API success rate >95%
- [ ] Average petition approval time <30 seconds
- [ ] Zero database errors
- [ ] User signup completion rate ≥ QuickLogin baseline

**Week 2-4**:
- [ ] Legal ID migration rate for existing users
- [ ] User satisfaction (NPS score)
- [ ] Support ticket volume (should not increase)

### 9.2 Monitoring Dashboards

**Metrics to Track**:
```
- neuro.remotelogin.petitions.created
- neuro.remotelogin.petitions.approved
- neuro.remotelogin.petitions.rejected
- neuro.remotelogin.petitions.timeout
- neuro.remotelogin.jwt.parse.errors
- neuro.remotelogin.jwt.verify.errors
- neuro.remotelogin.api.latency
- neuro.remotelogin.api.errors
```

**Alerts**:
```
- Error rate >5% (critical)
- Timeout rate >10% (warning)
- API latency >5 seconds (warning)
- JWT verification failures >1% (critical)
```

### 9.3 Documentation Updates

Post-migration:
- [ ] Update user-facing documentation
- [ ] Update API documentation
- [ ] Update deployment guides
- [ ] Update troubleshooting guides
- [ ] Update migration guides for other PDS operators

---

## 10. Open Questions & Decisions Needed

### 10.1 Legal ID Discovery

**Question**: How do users obtain their Legal ID?

**Options**:
1. Neuron app displays Legal ID prominently
2. PDS provides "Discover Legal ID" QR scan feature
3. Neuron API provides Legal ID lookup by email
4. Users copy-paste from Neuro settings

**Decision**: _________________

### 10.2 Existing User Migration

**Question**: How to handle existing QuickLogin users?

**Options**:
1. Force re-link with Legal ID
2. Keep JID-based auth for existing users
3. Dual lookup: Try Legal ID first, fall back to JID
4. Prompt users to link Legal ID next login

**Decision**: _________________

### 10.3 JWT Verification

**Question**: Should we verify JWT signatures?

**Considerations**:
- **Security**: Signature verification prevents token tampering
- **Performance**: Adds overhead (JWKS fetch + verification)
- **Complexity**: Requires public key management
- **Trust Model**: Do we trust Neuron's network security?

**Decision**: _________________

### 10.4 Purpose Message Format

**Question**: What should Purpose messages look like?

**Examples**:
- "Sign up for @alice.bsky.social"
- "Login to alice.bsky.social"
- "Link account @alice.bsky.social with Neuro"
- "Authorize access for alice.bsky.social"

**Decision**: _________________

### 10.5 QR Code Support

**Question**: Should we generate QR codes for RemoteLogin?

**Considerations**:
- Push notifications are primary method
- QR codes useful for cross-device scenarios
- QR code generation adds complexity
- Neuron may not provide QR endpoint for RemoteLogin

**Decision**: _________________

---

## 11. Risk Assessment (Neuro-Only Approach)

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Neuron API prolonged downtime** | Medium | **CRITICAL** | ⚠️ **NO FALLBACK** - 24/7 monitoring, SLA with Neuron provider, status page |
| **New user signup abandonment** | **HIGH** | High | Clear onboarding docs, "What is Neuro?" help flow, support chat during signup |
| **Existing password users locked out** | **HIGH** | Critical | ✅ **ACCEPTED RISK** - Security over convenience, announced prominently pre-launch |
| **Legal ID collection UX confusing** | High | Medium | User testing before launch, inline help text, video tutorials |
| **JWT verification breaks** | Low | High | Make verification optional via flag, extensive testing in staging |
| **Database migration data loss** | Low | Critical | Test in staging, full backups, rehearse migration, dry-run validation |
| **Petition timeout rate high** | Medium | Medium | Increase default timeout to 5 min, retry mechanism, clear error messaging |
| **Neuron privilege not granted** | High | **CRITICAL** | **BLOCKER** - Must coordinate with admin BEFORE implementation |
| **Neuro account creation friction** | **HIGH** | High | Cannot control - document KYC requirement prominently in all marketing |

### Critical Risk: Single Point of Failure

- **Problem**: If Neuron is down, entire PDS unavailable for all authentication
- **Impact**: 100% signup failure, 100% login failure (no fallback available)
- **Likelihood**: Medium
- **Mitigation**:
  - 24/7 monitoring of Neuron API status
  - Establish SLA with Neuron provider
  - Status page showing Neuron availability
  - Emergency contact with Neuron admin
  - **Accepted**: This is the security tradeoff for Neuro-only approach

### High Risk: User Onboarding Barrier

- **Problem**: New users MUST create Neuro account + pass KYC before PDS signup
- **Impact**: Higher barrier to entry, reduced conversion rate, user dropoff
- **Likelihood**: HIGH
- **Mitigation**:
  - Clear pre-signup documentation: "You'll need a Neuro account"
  - Link to Neuro signup from PDS signup page
  - Consider partnerships with Neuro for streamlined onboarding
  - A/B test messaging to optimize conversion

---

## 12. Timeline Estimate

**Assumptions**: 1 full-time developer, moderate complexity

| Phase | Duration | Tasks |
|-------|----------|-------|
| **Planning** | 3 days | Requirements, design decisions, stakeholder alignment |
| **Database** | 2 days | Schema changes, migrations, testing |
| **Backend Core** | 5 days | NeuronAuthClient, NeuroRemoteLoginManager, JWT parsing |
| **Integration** | 3 days | OAuth store changes, route handlers |
| **UI Changes** | 3 days | Legal ID input, waiting states, error handling |
| **Testing** | 5 days | Unit tests, integration tests, manual testing |
| **Staging Deploy** | 2 days | Deploy to staging, verify with real Neuron |
| **Production Deploy** | 2 days | Phased rollout, monitoring |
| **Total** | **25 days** (~5 weeks) | |

**Critical Path Items**:
1. Obtain Neuron credentials (blocks everything)
2. Legal ID collection UX decision (blocks UI work)
3. Database migration (blocks all testing)

---

## 13. Next Steps

**Immediate Actions**:

1. **[ ] Review this document** with team
2. **[ ] Make architectural decisions** (sections 10.1-10.5)
3. **[ ] Contact Neuron administrator** to:
   - Obtain credentials
   - Request privilege grants
   - Clarify Legal ID discovery process
   - Get JWKS endpoint (if doing JWT verification)
4. **[ ] Product/UX review**:
   - Review Legal ID collection UX mockups
   - Decide on messaging for petition approval
   - Review error states and messaging
5. **[ ] Create implementation tickets** from this guide
6. **[ ] Set up staging environment** with Neuron test instance
7. **[ ] Schedule kickoff meeting**

**Do NOT Proceed Until**:
- [ ] Neuron credentials obtained and tested
- [ ] Legal ID UX approved
- [ ] Database migration strategy approved
- [ ] Rollback plan reviewed
- [ ] Team alignment on timeline

---

## Appendix A: Glossary

- **Legal ID**: Neuron identifier format: `GUID@legal.domain.com`
- **JID**: Jabber ID, Neuron identifier format: `user@domain.com`
- **QuickLogin**: User-initiated authentication flow (current)
- **RemoteLogin**: Service-initiated authentication flow (target)
- **Petition**: RemoteLogin authentication request
- **PetitionId**: Unique identifier for a RemoteLogin petition

---

## Appendix B: References

- [RemoteLogin API Spec](https://lab.tagroot.io/Documentation/Neuron/RemoteLogin.md)
- [QuickLogin API Spec](https://lab.tagroot.io/Documentation/Neuron/QuickLogin.md)
- [Neuro RemoteLogin Flows](./neuro_remotelogin_flows.md)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [JWKS RFC 7517](https://tools.ietf.org/html/rfc7517)

---

**Document Version**: 1.0
**Last Updated**: January 2, 2026
**Status**: **REVIEW REQUIRED - DO NOT IMPLEMENT**
**Next Review Date**: _________________
**Approved By**: _________________
